<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  <title>SharedPreferences+MMAP+MMKV数据持久化原理解析 | chenyulong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <meta name="description" content="Nunu&#39;s blog!">
  
  
    <meta name="keywords" content="Nunu">
  
  
    <link rel="alternate" href="/atom.xml" title="chenyulong">
  
  
    <link rel="shortcut icon" href="/css/images/avatar.jpg">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" href="/localshare/css/share.css">
  
  
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">chenyulong</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">理论是你知道是这样，但它却不好用；实践是它很好用，但你不知道是为什么；程序员将理论和实践结合到一起：既不好用，也不知道是为什么。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> 首页</a>
        
          <a class="main-nav-link" href="/archives"><i class="fa fa-rss"></i> 归档</a>
        
          <a class="main-nav-link" href="/categories/"><i class="fa fa-archive"></i> 分类</a>
        
          <a class="main-nav-link" href="/tags/"><i class="fa fa-user"></i> 标签</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-SharedPreferences-MMAP-MMKV数据持久化原理解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      SharedPreferences+MMAP+MMKV数据持久化原理解析
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-06-03T10:09:55.000Z" itemprop="datePublished">2022年06月03日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

      
        <span class="article-views">
  <i class="fa fa-views"></i>
  <i id="busuanzi_container_page_pv">
      <i id="busuanzi_value_page_pv"></i>
  </i>
</span>

      
      
<a href="/2022/06/03/SharedPreferences-MMAP-MMKV数据持久化原理解析/#comments" class="article-comment-link">
  
    
    
    
    
    
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>SharedPreferences(以下统称为sp)是Android提供的数据持久化的一种手段，适合单进程、小批量的数据存储与访问。</li>
<li>由于sharedPreferences是基于xml文件实现的，所有持久化数据都是一次性加载，如果数据过大是不适合采用SP存放。</li>
<li>实际上是用xml文件存放数据，文件存保存放在/data/data//shared_prefs/<a id="more"></a>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences setting = getSharedPreferences(&quot;hello&quot;,MODE_PRIVATE);</span><br><span class="line">//让setting处于编辑状态</span><br><span class="line">SharedPreferences.Editor editor = setting.edit();</span><br><span class="line">//存放数据</span><br><span class="line">editor.putString(&quot;name&quot;,&quot;jacky&quot;);</span><br><span class="line">//完成提交</span><br><span class="line">editor.commit();</span><br><span class="line">// editor.apply();;</span><br><span class="line">//读取信息</span><br><span class="line">String name = setting.getString(&quot;name&quot;,&quot;0&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>如何获取SharedPreferences对象？getSharedPreferences方法是在ContextWrapper中，所以可以在Activity中直接获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    return mBase.getSharedPreferences(name, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现在ContextImpl中的getSharedPreferences方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(File file, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">        sp = cache.get(file);</span><br><span class="line">        if (sp == null) &#123;</span><br><span class="line">            sp = new SharedPreferencesImpl(file, mode);</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://nunu03.github.io/2022/06/03/SharedPreferences-MMAP-MMKV%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/sp-init.png" alt></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化：通过File读取文件,加载数据，然后通过XmlUtils解析文件。<br>SharedPreferencesImpl -&gt; startLoadFromDisk -&gt; loadFromDisk -&gt; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void loadFromDisk() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        if (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                str = new BufferedInputStream(</span><br><span class="line">                        new FileInputStream(mFile), 16 * 1024);</span><br><span class="line">                map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>commit -&gt; enqueueDiskWrite -&gt; writeToFile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public boolean commit() &#123;</span><br><span class="line">    long startTime = 0;</span><br><span class="line"></span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(</span><br><span class="line">        mcr, null /* sync write on this thread okay */);</span><br><span class="line">    try &#123;</span><br><span class="line">         //这个地方就让主线程卡住的原因，如果多个commit，就需要等待，就会阻塞。</span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                    + &quot; committed after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                    + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    return mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                                final Runnable postWriteRunnable) &#123;</span><br><span class="line">    final boolean isFromSyncCommit = (postWriteRunnable == null);</span><br><span class="line"></span><br><span class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (postWriteRunnable != null) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    // 未true是commit提交，在当前线程提交，注意这里的锁.</span><br><span class="line">    if (isFromSyncCommit) &#123;</span><br><span class="line">        boolean wasEmpty = false;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            wasEmpty = mDiskWritesInFlight == 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wasEmpty) &#123;</span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // apply 如队列</span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在commit方法中，首先执行写入任务也就是enqueueDiskWrite这个方法，然后让调用线程处于等待状态，当写入任务执行成功后唤起调用commit的线程，假设调用commit的线程就是主线线程，并且写入任务耗时还比较多的，这不就阻塞住主线程了吗？</p>
<h4 id="writeToFile"><a href="#writeToFile" class="headerlink" title="writeToFile"></a>writeToFile</h4><p>直接io操作写入的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void writeToFile(MemoryCommitResult mcr, boolean isFromSyncCommit) &#123;</span><br><span class="line">    long startTime = 0;</span><br><span class="line">    long existsTime = 0;</span><br><span class="line">    long backupExistsTime = 0;</span><br><span class="line">    long outputStreamCreateTime = 0;</span><br><span class="line">    long writeTime = 0;</span><br><span class="line">    long fsyncTime = 0;</span><br><span class="line">    long setPermTime = 0;</span><br><span class="line">    long fstatTime = 0;</span><br><span class="line">    long deleteTime = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line"></span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            outputStreamCreateTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (str == null) &#123;</span><br><span class="line">            mcr.setDiskWriteResult(false, false);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line"></span><br><span class="line">        writeTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        FileUtils.sync(str);</span><br><span class="line"></span><br><span class="line">        fsyncTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        str.close();</span><br><span class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>apply -&gt; 异步延迟加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void apply() &#123;</span><br><span class="line">    final long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    final MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    final Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                    Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                            + &quot; applied after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                            + &quot; ms&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    // 这个是保存到QueuedWork队列， 添加到LinkedList&lt;Runnable&gt; sFinishers = new LinkedList&lt;&gt;();里</span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    // Okay to notify the listeners before it&apos;s hit disk</span><br><span class="line">    // because the listeners should always get the same</span><br><span class="line">    // SharedPreferences instance back, which has the</span><br><span class="line">    // changes reflected in memory.</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入队列，创建handler，sWork队列中数据最终在queued-work-looper 线程中依次得到执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> public static void queue(Runnable work, boolean shouldDelay) &#123;</span><br><span class="line">    Handler handler = getHandler();</span><br><span class="line"></span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        sWork.add(work);</span><br><span class="line"></span><br><span class="line">        if (shouldDelay &amp;&amp; sCanDelay) &#123;</span><br><span class="line">            handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终processPendingWork执行，实际上就是for循环，轮询执行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static void processPendingWork() &#123;</span><br><span class="line">    long startTime = 0;</span><br><span class="line"></span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (sProcessingWork) &#123;</span><br><span class="line">        LinkedList&lt;Runnable&gt; work;</span><br><span class="line"></span><br><span class="line">        synchronized (sLock) &#123;</span><br><span class="line">            work = (LinkedList&lt;Runnable&gt;) sWork.clone();</span><br><span class="line">            sWork.clear();</span><br><span class="line"></span><br><span class="line">            // Remove all msg-s as all work will be processed now</span><br><span class="line">            getHandler().removeMessages(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (work.size() &gt; 0) &#123;</span><br><span class="line">            for (Runnable w : work) &#123;</span><br><span class="line">                w.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>apply的中写入操作也是在异步线程执行，不会导致主线程卡顿，但是如果异步任务执行时间过长，当ActvityThread执行了handleStopActivity或者handleServiceArgs或者handlePauseActivity 等方法的时候都会调用QueuedWork.waitToFinish()方法,而此方法中会在异步任务执行完成前一直阻塞住主线程，所以卡顿问题就产生了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public static void waitToFinish() &#123;</span><br><span class="line">       long startTime = System.currentTimeMillis();</span><br><span class="line">       boolean hadMessages = false;</span><br><span class="line"></span><br><span class="line">       Handler handler = getHandler();</span><br><span class="line"></span><br><span class="line">       synchronized (sLock) &#123;</span><br><span class="line">           if (handler.hasMessages(QueuedWorkHandler.MSG_RUN)) &#123;</span><br><span class="line">               // Delayed work will be processed at processPendingWork() below</span><br><span class="line">               handler.removeMessages(QueuedWorkHandler.MSG_RUN);</span><br><span class="line"></span><br><span class="line">               if (DEBUG) &#123;</span><br><span class="line">                   hadMessages = true;</span><br><span class="line">                   Log.d(LOG_TAG, &quot;waiting&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // We should not delay any work as this might delay the finishers</span><br><span class="line">           sCanDelay = false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">       try &#123;</span><br><span class="line">           processPendingWork();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           while (true) &#123;</span><br><span class="line">               Runnable finisher;</span><br><span class="line"></span><br><span class="line">               synchronized (sLock) &#123;</span><br><span class="line">                   finisher = sFinishers.poll();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (finisher == null) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               finisher.run();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           sCanDelay = true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized (sLock) &#123;</span><br><span class="line">           long waitTime = System.currentTimeMillis() - startTime;</span><br><span class="line"></span><br><span class="line">           if (waitTime &gt; 0 || hadMessages) &#123;</span><br><span class="line">               mWaitTimes.add(Long.valueOf(waitTime).intValue());</span><br><span class="line">               mNumWaits++;</span><br><span class="line"></span><br><span class="line">               if (DEBUG || mNumWaits % 1024 == 0 || waitTime &gt; MAX_WAIT_TIME_MILLIS) &#123;</span><br><span class="line">                   mWaitTimes.log(LOG_TAG, &quot;waited: &quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>会从sFinishers队列中取出数据然后执行run方法，我们别忘了在apply的方法中，我们还添加了QueuedWork.addFinisher(awaitCommit);这个awaitCommit 就得到执行了但是awaitCommit中的代码确实是阻塞的代码，等待写入线程执行完毕才能唤起此线程。如果 apply中的写入代码不执行完，主线程就一直卡住了，也就出现了我们上面的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> final Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mcr.writtenToDiskLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">            Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                    + &quot; applied after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                    + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int getInt(String key, int defValue) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        Integer v = (Integer)mMap.get(key);</span><br><span class="line">        return v != null ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键awaitLoadedLocked 这个方法，当数据没有加载完，就让调用的线程处于等待中，阻塞住了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void awaitLoadedLocked() &#123;</span><br><span class="line">    if (!mLoaded) &#123;</span><br><span class="line">        // Raise an explicit StrictMode onReadFromDisk for this</span><br><span class="line">        // thread, since the real read will be in a different</span><br><span class="line">        // thread and otherwise ignored by StrictMode.</span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!mLoaded) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; catch (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mThrowable != null) &#123;</span><br><span class="line">        throw new IllegalStateException(mThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以获取数据也是阻塞的。</p>
<h4 id="源码总结"><a href="#源码总结" class="headerlink" title="源码总结"></a>源码总结</h4><p>从上面可以看出两者最后都是先调用commitToMemory，将更改提交到内存，在这一点上两者是一致的，之后又都调用了enqueueDiskWrite进行数据持久化任务，不过commit函数一般会在当前线程直接写文件，而apply则提交到一个队列里，延迟加载，之后直接返回。<br>（这里代码是android-28，可能新版本是是一个线程池，而非队列）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li>xml格式保存</li>
<li>通过子线程使用IO读取整个文件，并进行xml解析，存入内存Map，完成初始化，默认大小是16k。</li>
<li>commit是同步提交，阻塞调用的线程，为啥？如果是使用commit方式提交，会阻塞调用commit方法的线程，如果写入任务很多比较耗时，就卡住了，所以不要在主线程执行写入文件的操作，否则阻塞主线程；apply是异步(延迟)提交，无法获取结果且可能数据丢失。apply 放法不会阻塞调用的线程，但是如果写入任务比较耗时，会阻塞住主线程，因为主线程有调用的代码，需要等写入任务执行完了才会继续往下执行。</li>
<li>更新，是吧map中数据，全部序列化XML，覆盖文件保存（全量更新）。<br>所以有没有一种方案改进sp的xml，io，并发问题？</li>
</ul>
</blockquote>
<h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h2><h3 id="传统I-O"><a href="#传统I-O" class="headerlink" title="传统I/O"></a>传统I/O</h3><p>虚拟内存被操作系统划分为两块：用户空间和内核空间，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方，内核空间由所有进程共享。为了安全，他们是隔离的，即使用户的程序崩溃了，内核也不受影响。<br>写文件的流程：<br><img src="http://nunu03.github.io/2022/06/03/SharedPreferences-MMAP-MMKV%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/sp-io.png" alt><br>1、调用write，告诉内核需要写入数据的开始地址与长度。<br>2、内核将数据拷贝到内核页缓存。<br>3、由操作系统调用，将数据拷贝到磁盘，完成写入。</p>
<h3 id="MMMAP"><a href="#MMMAP" class="headerlink" title="MMMAP"></a>MMMAP</h3><p>Linux 通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping).<br>对文件进行mmap，会在进程的虚拟内存分配地址空间创建映射关系。实现这样的映射关系后，就可以采用指针的方式读写操作这一段内存，而系统会自动回写到对应的文件磁盘上。<br><img src="http://nunu03.github.io/2022/06/03/SharedPreferences-MMAP-MMKV%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/sp-mmap.png" alt></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>MMAP对文件的读写操作只需要从磁盘到用户主存的一次数据拷贝过程，减少了数据的拷贝次数，提高了文件操作效率</li>
<li>MMAP使用逻辑内存对磁盘文件进行映射，操作内存就相当于操作文件，不需要开启线程，操作MMAP的速度和操作内存的速度一样快</li>
<li>MMAP提供一段可供随时写入的内存块，App只管往里面写数据，由操作系统如内存不足、进程退出等时候负责将内存回写到文件。<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4>微信Mars：<br><a href="https://github.com/Tencent/mars" target="_blank" rel="noopener">github</a><br><a href="https://mp.weixin.qq.com/s/cnhuEodJGIbdodh0IxNeXQ" target="_blank" rel="noopener">文档</a><br>美团Logan：<br><a href="https://github.com/Meituan-Dianping/Logan/tree/master/Example/Logan-Android" target="_blank" rel="noopener">github</a><br><a href="https://tech.meituan.com/2018/02/11/logan.html" target="_blank" rel="noopener">博客</a><br>网易android-mmap：<h4 id="Binder通信"><a href="#Binder通信" class="headerlink" title="Binder通信"></a>Binder通信</h4><img src="http://nunu03.github.io/2022/06/03/SharedPreferences-MMAP-MMKV%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/sp-binder.png" alt><h2 id="MMKV"><a href="#MMKV" class="headerlink" title="MMKV"></a>MMKV</h2>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></li>
<li>内存准备<br>通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。</li>
<li>数据组织<br>数据序列化方面我们选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现。</li>
<li>写入优化<br>考虑到主要使用场景是频繁地进行写入更新，我们需要有增量更新的能力。我们考虑将增量 kv 对象序列化后，append 到内存末尾。</li>
<li>空间增长<br>使用 append 实现增量更新带来了一个新的问题，就是不断 append 的话，文件大小会增长得不可控。我们需要在性能和空间上做个折中。<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MMKV_JNI void jniInitialize(JNIEnv *env, jobject obj, jstring rootDir, jstring cacheDir, jint logLevel) &#123;</span><br><span class="line">    if (!rootDir) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取rootDir的url char指针数组字符串，调⽤MMKV::initializeMMKV进⼀步初始化。</span><br><span class="line">    const char *kstr = env-&gt;GetStringUTFChars(rootDir, nullptr);</span><br><span class="line">    if (kstr) &#123;</span><br><span class="line">        MMKV::initializeMMKV(kstr, (MMKVLogLevel) logLevel);</span><br><span class="line">        env-&gt;ReleaseStringUTFChars(rootDir, kstr);</span><br><span class="line"></span><br><span class="line">        g_android_tmpDir = jstring2string(env, cacheDir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadOnceToken_t once_control = ThreadOnceUninitialized;</span><br><span class="line">void MMKV::initializeMMKV(const MMKVPath_t &amp;rootDir, MMKVLogLevel logLevel) &#123;</span><br><span class="line">    g_currentLogLevel = logLevel;</span><br><span class="line">    ThreadLock::ThreadOnce(&amp;once_control, initialize);</span><br><span class="line">    // 获取rootDir的url char指针数组字符串</span><br><span class="line">    g_rootDir = rootDir;</span><br><span class="line">    // 根据路径创建⽂件夹</span><br><span class="line">    mkPath(g_rootDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="获取MMKV对象"><a href="#获取MMKV对象" class="headerlink" title="获取MMKV对象"></a>获取MMKV对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MMKV *MMKV::mmkvWithID(const string &amp;mmapID, MMKVMode mode, string *cryptKey, MMKVPath_t *rootPath) &#123;</span><br><span class="line"></span><br><span class="line">    if (mmapID.empty()) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    // 加锁 </span><br><span class="line">    SCOPED_LOCK(g_instanceLock);</span><br><span class="line">    // 将 mmapID 与 relativePath 结合生成 mmapKey </span><br><span class="line">    auto mmapKey = mmapedKVKey(mmapID, rootPath);</span><br><span class="line">    // 通过 mmapKey 在 map 中查找对应的 MMKV 对象并返回 </span><br><span class="line">    auto itr = g_instanceDic-&gt;find(mmapKey);</span><br><span class="line">    if (itr != g_instanceDic-&gt;end()) &#123;</span><br><span class="line">        MMKV *kv = itr-&gt;second;</span><br><span class="line">        return kv;</span><br><span class="line">    &#125;</span><br><span class="line">   // 如果找不到，构建路径后构建 MMKV 对象并加入 map </span><br><span class="line">    if (rootPath) &#123;</span><br><span class="line">        MMKVPath_t specialPath = (*rootPath) + MMKV_PATH_SLASH + SPECIAL_CHARACTER_DIRECTORY_NAME;</span><br><span class="line">        if (!isFileExist(specialPath)) &#123;</span><br><span class="line">            mkPath(specialPath);</span><br><span class="line">        &#125;</span><br><span class="line">        MMKVInfo(&quot;prepare to load %s (id %s) from rootPath %s&quot;, mmapID.c_str(), mmapKey.c_str(), rootPath-&gt;c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造对象</span><br><span class="line">    auto kv = new MMKV(mmapID, mode, cryptKey, rootPath);</span><br><span class="line">    kv-&gt;m_mmapKey = mmapKey;</span><br><span class="line">    (*g_instanceDic)[mmapKey] = kv;</span><br><span class="line">    return kv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取path</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">extern bool mkPath(const MMKVPath_t &amp;str) &#123;</span><br><span class="line">    // strdup拷贝⼀份字符串到path中。</span><br><span class="line">    char *path = strdup(str.c_str());</span><br><span class="line"></span><br><span class="line">    struct stat sb = &#123;&#125;;</span><br><span class="line">    bool done = false;</span><br><span class="line">    char *slash = path;</span><br><span class="line"></span><br><span class="line">    while (!done) &#123;</span><br><span class="line">        // strspn 是⼀直找到匹配字符串，直到出现第⼀个不是&quot;/&quot;</span><br><span class="line">        slash += strspn(slash, &quot;/&quot;);</span><br><span class="line">        // strcspn 则是⼀直找不匹配的字符串，直到出现第⼀个“/”</span><br><span class="line">        slash += strcspn(slash, &quot;/&quot;);</span><br><span class="line">        // 经过这样拆解，就能把路径⼀个个分割开。通过这中⽅式就能直到什么时候遍历完整个路径。</span><br><span class="line">        done = (*slash == &apos;\0&apos;);</span><br><span class="line">        *slash = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">        // stat获取path每⼀个⽂件夹的权限状态，必须保证每⼀级别的⽂件都是0777，也就是读写执⾏全部权限打开。</span><br><span class="line"></span><br><span class="line">        if (stat(path, &amp;sb) != 0) &#123;</span><br><span class="line">            if (errno != ENOENT || mkdir(path, 0777) != 0) &#123;</span><br><span class="line">                MMKVWarning(&quot;%s : %s&quot;, path, strerror(errno));</span><br><span class="line">                free(path);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (!S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">            MMKVWarning(&quot;%s: %s&quot;, path, strerror(ENOTDIR));</span><br><span class="line">            free(path);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *slash = &apos;/&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    free(path);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">MMKV::MMKV(const string &amp;mmapID, MMKVMode mode, string *cryptKey, MMKVPath_t *rootPath)&#123;</span><br><span class="line">    .......</span><br><span class="line">     // 通过加密 key 构建 AES 加密对象 AESCrypt </span><br><span class="line">    #    ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">    if (cryptKey &amp;&amp; cryptKey-&gt;length() &gt; 0) &#123;</span><br><span class="line">        m_dicCrypt = new MMKVMapCrypt();</span><br><span class="line">        m_crypter = new AESCrypt(cryptKey-&gt;data(), cryptKey-&gt;length());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        m_dic = new MMKVMap();</span><br><span class="line">    &#125;</span><br><span class="line">#    else</span><br><span class="line">    m_dic = new MMKVMap();</span><br><span class="line">#    endif</span><br><span class="line">     ...................................</span><br><span class="line">     m_lock-&gt;initialize();</span><br><span class="line">     ................</span><br><span class="line">       // sensitive zone</span><br><span class="line">       // 加锁后通过 loadFromFile 方法从文件中读取数据，这里的锁是一个跨进程的文件共享锁;</span><br><span class="line">    &#123;</span><br><span class="line">        SCOPED_LOCK(m_sharedProcessLock);</span><br><span class="line">        loadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void initialize() &#123;</span><br><span class="line">    g_instanceDic = new unordered_map&lt;string, MMKV *&gt;;</span><br><span class="line">    // 初始化了⼀个全局的线程锁</span><br><span class="line">    g_instanceLock = new ThreadLock();</span><br><span class="line">    g_instanceLock-&gt;initialize();</span><br><span class="line">    // 。在MMKV中，设置好每⼀页(page)的⼤⼩，⼀般来说我们在32位的机⼦中⼀页都是</span><br><span class="line">    4kb⼤⼩</span><br><span class="line">    mmkv::DEFAULT_MMAP_SIZE = mmkv::getPageSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加载数据loadFromFile"><a href="#加载数据loadFromFile" class="headerlink" title="加载数据loadFromFile"></a>加载数据loadFromFile</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">void MMKV::loadFromFile() &#123;</span><br><span class="line">    //读缓存</span><br><span class="line">        if (m_metaFile-&gt;isFileValid()) &#123;</span><br><span class="line">        m_metaInfo-&gt;read(m_metaFile-&gt;getMemory());</span><br><span class="line">    &#125;</span><br><span class="line">    //读文件</span><br><span class="line">    if (!m_file-&gt;isFileValid()) &#123;</span><br><span class="line">        m_file-&gt;reloadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // loading 开始加载</span><br><span class="line">    if (loadFromFile &amp;&amp; m_actualSize &gt; 0) &#123;</span><br><span class="line">        MMKVInfo(&quot;loading [%s] with crc %u sequence %u version %u&quot;, m_mmapID.c_str(), m_metaInfo-&gt;m_crcDigest,</span><br><span class="line">                    m_metaInfo-&gt;m_sequence, m_metaInfo-&gt;m_version);</span><br><span class="line">        // 读取 MMBuffer </span><br><span class="line">        MMBuffer inputBuffer(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);</span><br><span class="line">        // 如果需要解密，对文件进行解密 </span><br><span class="line">        if (m_crypter) &#123;</span><br><span class="line">            clearDictionary(m_dicCrypt);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            clearDictionary(m_dic);</span><br><span class="line">        &#125;</span><br><span class="line">         // 通过 MiniPBCoder 将 MMBuffer 转换为 Map </span><br><span class="line">        if (needFullWriteback) &#123;</span><br><span class="line">#ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">            if (m_crypter) &#123;</span><br><span class="line">                MiniPBCoder::greedyDecodeMap(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class="line">            &#125; else</span><br><span class="line">#endif</span><br><span class="line">            &#123;</span><br><span class="line">                MiniPBCoder::greedyDecodeMap(*m_dic, inputBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">#ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">            if (m_crypter) &#123;</span><br><span class="line">                MiniPBCoder::decodeMap(*m_dicCrypt, inputBuffer, m_crypter);</span><br><span class="line">            &#125; else</span><br><span class="line">#endif</span><br><span class="line">            &#123;</span><br><span class="line">                MiniPBCoder::decodeMap(*m_dic, inputBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         // 构造用于输出的 CodeOutputData </span><br><span class="line">        m_output = new CodedOutputData(ptr + Fixed32Size, m_file-&gt;getFileSize() - Fixed32Size);</span><br><span class="line">        m_output-&gt;seek(m_actualSize);</span><br><span class="line">        if (needFullWriteback) &#123;</span><br><span class="line">            fullWriteback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // file not valid or empty, discard everything</span><br><span class="line">        SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line"></span><br><span class="line">        m_output = new CodedOutputData(ptr + Fixed32Size, m_file-&gt;getFileSize() - Fixed32Size);</span><br><span class="line">        if (m_actualSize &gt; 0) &#123;</span><br><span class="line">            writeActualSize(0, 0, nullptr, IncreaseSequence);</span><br><span class="line">            sync(MMKV_SYNC);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            writeActualSize(0, 0, nullptr, KeepSequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MemoryFile::reloadFromFile() &#123;</span><br><span class="line">    ....................</span><br><span class="line">    if (!m_diskFile.open()) &#123;</span><br><span class="line">        MMKVError(&quot;fail to open:%s, %s&quot;, m_diskFile.m_path.c_str(), strerror(errno));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        FileLock fileLock(m_diskFile.m_fd);</span><br><span class="line">        InterProcessLock lock(&amp;fileLock, ExclusiveLockType);</span><br><span class="line">        SCOPED_LOCK(&amp;lock);</span><br><span class="line">        // 页文件大小，32位大概是4k</span><br><span class="line">        mmkv::getFileSize(m_diskFile.m_fd, m_size);</span><br><span class="line">        // round up to (n * pagesize)</span><br><span class="line">         // 将文件大小对齐到页大小的整数倍，用 0 填充不足的部分 </span><br><span class="line">        if (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) &#123;</span><br><span class="line">            size_t roundSize = ((m_size / DEFAULT_MMAP_SIZE) + 1) * DEFAULT_MMAP_SIZE;</span><br><span class="line">            truncate(roundSize);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            auto ret = mmap();</span><br><span class="line">            if (!ret) &#123;</span><br><span class="line">                doCleanMemoryCache(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#    ifdef MMKV_IOS</span><br><span class="line">        tryResetFileProtection(m_diskFile.m_path);</span><br><span class="line">#    endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool File::open() &#123;</span><br><span class="line">    // 打开对应的文件 </span><br><span class="line">    m_fd = ::open(m_path.c_str(), OpenFlag2NativeFlag(m_flag), S_IRWXU);</span><br><span class="line">    if (!isFileValid()) &#123;</span><br><span class="line">        MMKVError(&quot;fail to open [%s], %d(%s)&quot;, m_path.c_str(), errno, strerror(errno));</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    MMKVInfo(&quot;open fd[%p], %s&quot;, m_fd, m_path.c_str());</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过 mmap 将文件映射到内存</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool MemoryFile::mmap() &#123;</span><br><span class="line">    //通过 mmap 将文件映射到内存 </span><br><span class="line">    m_ptr = (char *) ::mmap(m_ptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_diskFile.m_fd, 0);</span><br><span class="line">    if (m_ptr == MAP_FAILED) &#123;</span><br><span class="line">        MMKVError(&quot;fail to mmap [%s], %s&quot;, m_diskFile.m_path.c_str(), strerror(errno));</span><br><span class="line">        m_ptr = nullptr;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>Java 层的 MMKV 对象继承了 SharedPreferences 及 SharedPreferences.Editor 接口并实现了一系列如 putInt、putLong 的方法用于对存储的数据进行修改;最终还是会进入c方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::set(int32_t value, MMKVKey_t key) &#123;</span><br><span class="line">    if (isKeyEmpty(key)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t size = pbInt32Size(value);</span><br><span class="line">    MMBuffer data(size);</span><br><span class="line">    // 构造值对应的 MMBuffer，通过 CodedOutputData 将其写入 Buffer</span><br><span class="line">    CodedOutputData output(data.getPtr(), size);</span><br><span class="line">    output.writeInt32(value);</span><br><span class="line"></span><br><span class="line">    return setDataForKey(move(data), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到了写入的 value 在 protobuf 中所占据的大小，之后为其构造了对应的 MMBuffer 并将数据写入了这段 Buffer，最后调用到了 setDataForKey 方法;同时可以发现 CodedOutputData 是与 Buffer 交互的桥梁，可以通过它实现向 MMBuffer 中写入数据;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">bool MMKV::setDataForKey(MMBuffer &amp;&amp;data, MMKVKey_t key, bool isDataHolder) &#123;</span><br><span class="line">    if ((!isDataHolder &amp;&amp; data.length() == 0) || isKeyEmpty(key)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">     // 获取写锁 </span><br><span class="line">    SCOPED_LOCK(m_lock);</span><br><span class="line">    SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line">    // 确保数据已读入内存 </span><br><span class="line">    checkLoadData();</span><br><span class="line"></span><br><span class="line">#ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        if (isDataHolder) &#123;</span><br><span class="line">            auto sizeNeededForData = pbRawVarint32Size((uint32_t) data.length()) + data.length();</span><br><span class="line">            if (!KeyValueHolderCrypt::isValueStoredAsOffset(sizeNeededForData)) &#123;</span><br><span class="line">                data = MiniPBCoder::encodeDataWithObject(data);</span><br><span class="line">                isDataHolder = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 data 写入 map 中 </span><br><span class="line">        auto itr = m_dicCrypt-&gt;find(key);</span><br><span class="line">        if (itr != m_dicCrypt-&gt;end()) &#123;</span><br><span class="line">#    ifdef MMKV_APPLE</span><br><span class="line">            auto ret = appendDataWithKey(data, key, itr-&gt;second, isDataHolder);</span><br><span class="line">#    else</span><br><span class="line">            auto ret = appendDataWithKey(data, key, isDataHolder);</span><br><span class="line">#    endif</span><br><span class="line">            if (!ret.first) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (KeyValueHolderCrypt::isValueStoredAsOffset(ret.second.valueSize)) &#123;</span><br><span class="line">                KeyValueHolderCrypt kvHolder(ret.second.keySize, ret.second.valueSize, ret.second.offset);</span><br><span class="line">                memcpy(&amp;kvHolder.cryptStatus, &amp;t_status, sizeof(t_status));</span><br><span class="line">                itr-&gt;second = move(kvHolder);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                itr-&gt;second = KeyValueHolderCrypt(move(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            auto ret = appendDataWithKey(data, key, isDataHolder);</span><br><span class="line">            if (!ret.first) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (KeyValueHolderCrypt::isValueStoredAsOffset(ret.second.valueSize)) &#123;</span><br><span class="line">                auto r = m_dicCrypt-&gt;emplace(</span><br><span class="line">                    key, KeyValueHolderCrypt(ret.second.keySize, ret.second.valueSize, ret.second.offset));</span><br><span class="line">                if (r.second) &#123;</span><br><span class="line">                    memcpy(&amp;(r.first-&gt;second.cryptStatus), &amp;t_status, sizeof(t_status));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                m_dicCrypt-&gt;emplace(key, KeyValueHolderCrypt(move(data)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else</span><br><span class="line">#endif // MMKV_DISABLE_CRYPT</span><br><span class="line">    &#123;</span><br><span class="line">        auto itr = m_dic-&gt;find(key);</span><br><span class="line">        if (itr != m_dic-&gt;end()) &#123;</span><br><span class="line">            auto ret = appendDataWithKey(data, itr-&gt;second, isDataHolder);</span><br><span class="line">            if (!ret.first) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            itr-&gt;second = std::move(ret.second);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            auto ret = appendDataWithKey(data, key, isDataHolder);</span><br><span class="line">            if (!ret.first) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            m_dic-&gt;emplace(key, std::move(ret.second));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_hasFullWriteback = false;</span><br><span class="line">#ifdef MMKV_APPLE</span><br><span class="line">    [key retain];</span><br><span class="line">#endif</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据已读入内存的情况下将 data 写入了对应的 map，之后调用了 appendDataWithKey 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &amp;data, const KeyValueHolder &amp;kvHolder, bool isDataHolder) &#123;</span><br><span class="line">    SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line"></span><br><span class="line">    uint32_t keyLength = kvHolder.keySize;</span><br><span class="line">    // size needed to encode the key</span><br><span class="line">    // 计算写入到映射空间中的 size </span><br><span class="line">    size_t rawKeySize = keyLength + pbRawVarint32Size(keyLength);</span><br><span class="line"></span><br><span class="line">    // ensureMemorySize() might change kvHolder.offset, so have to do it early</span><br><span class="line">    &#123;</span><br><span class="line">        auto valueLength = static_cast&lt;uint32_t&gt;(data.length());</span><br><span class="line">        if (isDataHolder) &#123;</span><br><span class="line">            valueLength += pbRawVarint32Size(valueLength);</span><br><span class="line">        &#125;</span><br><span class="line">        auto size = rawKeySize + valueLength + pbRawVarint32Size(valueLength);</span><br><span class="line">        // 确定剩余映射空间足够 </span><br><span class="line">        bool hasEnoughSize = ensureMemorySize(size);</span><br><span class="line">        if (!hasEnoughSize) &#123;</span><br><span class="line">            return make_pair(false, KeyValueHolder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    auto basePtr = (uint8_t *) m_file-&gt;getMemory() + Fixed32Size;</span><br><span class="line">    MMBuffer keyData(basePtr + kvHolder.offset, rawKeySize, MMBufferNoCopy);</span><br><span class="line"></span><br><span class="line">    return doAppendDataWithKey(data, keyData, isDataHolder, keyLength);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MMKV::doAppendDataWithKey(const MMBuffer &amp;data, const MMBuffer &amp;keyData, bool isDataHolder, uint32_t originKeyLength) &#123;</span><br><span class="line">    auto isKeyEncoded = (originKeyLength &lt; keyData.length());</span><br><span class="line">    auto keyLength = static_cast&lt;uint32_t&gt;(keyData.length());</span><br><span class="line">    auto valueLength = static_cast&lt;uint32_t&gt;(data.length());</span><br><span class="line">    if (isDataHolder) &#123;</span><br><span class="line">        valueLength += pbRawVarint32Size(valueLength);</span><br><span class="line">    &#125;</span><br><span class="line">    // size needed to encode the key</span><br><span class="line">    size_t size = isKeyEncoded ? keyLength : (keyLength + pbRawVarint32Size(keyLength));</span><br><span class="line">    // size needed to encode the value</span><br><span class="line">    size += valueLength + pbRawVarint32Size(valueLength);</span><br><span class="line"></span><br><span class="line">    SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line"></span><br><span class="line">    bool hasEnoughSize = ensureMemorySize(size);</span><br><span class="line">    if (!hasEnoughSize || !isFileValid()) &#123;</span><br><span class="line">        return make_pair(false, KeyValueHolder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef MMKV_IOS</span><br><span class="line">    auto ret = guardForBackgroundWriting(m_output-&gt;curWritePointer(), size);</span><br><span class="line">    if (!ret.first) &#123;</span><br><span class="line">        return make_pair(false, KeyValueHolder());</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">#ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        if (KeyValueHolderCrypt::isValueStoredAsOffset(valueLength)) &#123;</span><br><span class="line">            m_crypter-&gt;getCurStatus(t_status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    // 重新构建并写入数据 </span><br><span class="line">    try &#123;</span><br><span class="line">        if (isKeyEncoded) &#123;</span><br><span class="line">            m_output-&gt;writeRawData(keyData);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            m_output-&gt;writeData(keyData);</span><br><span class="line">        &#125;</span><br><span class="line">        if (isDataHolder) &#123;</span><br><span class="line">            m_output-&gt;writeRawVarint32((int32_t) valueLength);</span><br><span class="line">        &#125;</span><br><span class="line">        m_output-&gt;writeData(data); // note: write size of data</span><br><span class="line">    &#125; catch (std::exception &amp;e) &#123;</span><br><span class="line">        MMKVError(&quot;%s&quot;, e.what());</span><br><span class="line">        return make_pair(false, KeyValueHolder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto offset = static_cast&lt;uint32_t&gt;(m_actualSize);</span><br><span class="line">    auto ptr = (uint8_t *) m_file-&gt;getMemory() + Fixed32Size + m_actualSize;</span><br><span class="line">#ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        m_crypter-&gt;encrypt(ptr, ptr, size);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    m_actualSize += size;</span><br><span class="line">    updateCRCDigest(ptr, size);</span><br><span class="line"></span><br><span class="line">    return make_pair(true, KeyValueHolder(originKeyLength, valueLength, offset));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CodedOutputData::writeRawData(const MMBuffer &amp;data) &#123;</span><br><span class="line">    size_t numberOfBytes = data.length();</span><br><span class="line">    if (m_position + numberOfBytes &gt; m_size) &#123;</span><br><span class="line">        auto msg = &quot;m_position: &quot; + to_string(m_position) + &quot;, numberOfBytes: &quot; + to_string(numberOfBytes) +</span><br><span class="line">                   &quot;, m_size: &quot; + to_string(m_size);</span><br><span class="line">        throw out_of_range(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(m_ptr + m_position, data.getPtr(), numberOfBytes);</span><br><span class="line">    m_position += numberOfBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意的是</strong>：由于 protobuf 不支持增量更新，为了避免全量写入带来的性能问题，MMKV 在文件中的写入并不是通过修改文件对应的位置，而是直接在后面 append 一条新的数据，即使是修改了已存在的 key。而读取时只记录最后一条对应 key 的数据，这样显然会在文件中存在冗余的数据。这样设计的原因我认为是出于性能的考量，MMKV 中存在着一套内存重整机制用于对冗余的 key-value 数据进行处理。它正是在确保内存充足时实现的;</p>
<h4 id="内存重整ensureMemorySize"><a href="#内存重整ensureMemorySize" class="headerlink" title="内存重整ensureMemorySize"></a>内存重整ensureMemorySize</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// since we use append mode, when -[setData: forKey:] many times, space may not be enough</span><br><span class="line">// try a full rewrite to make space</span><br><span class="line">bool MMKV::ensureMemorySize(size_t newSize) &#123;</span><br><span class="line">    // 如果内存剩余大小不足以写入，尝试进行内存重整，将 map 中的数据重新写入 protobuf 文件 </span><br><span class="line">    if (newSize &gt;= m_output-&gt;spaceLeft() || (m_crypter ? m_dicCrypt-&gt;empty() : m_dic-&gt;empty())) &#123;</span><br><span class="line">        // try a full rewrite to make space</span><br><span class="line">        auto fileSize = m_file-&gt;getFileSize();</span><br><span class="line">        auto preparedData = m_crypter ? prepareEncode(*m_dicCrypt) : prepareEncode(*m_dic);</span><br><span class="line">        auto sizeOfDic = preparedData.second;</span><br><span class="line">        size_t lenNeeded = sizeOfDic + Fixed32Size + newSize;</span><br><span class="line">        size_t dicCount = m_crypter ? m_dicCrypt-&gt;size() : m_dic-&gt;size();</span><br><span class="line">        size_t avgItemSize = lenNeeded / std::max&lt;size_t&gt;(1, dicCount);</span><br><span class="line">        size_t futureUsage = avgItemSize * std::max&lt;size_t&gt;(8, (dicCount + 1) / 2);</span><br><span class="line">        // 1. no space for a full rewrite, double it</span><br><span class="line">        // 2. or space is not large enough for future usage, double it to avoid frequently full rewrite</span><br><span class="line">        if (lenNeeded &gt;= fileSize || (lenNeeded + futureUsage) &gt;= fileSize) &#123;</span><br><span class="line">            size_t oldSize = fileSize;</span><br><span class="line">            // 如果内存重整后仍不足以写入，则将大小不断乘2直至足够写入，最后通过 mmap 重新映射文件 </span><br><span class="line">            do &#123;</span><br><span class="line">                 // double 空间直至足够 </span><br><span class="line">                fileSize *= 2;</span><br><span class="line">            &#125; while (lenNeeded + futureUsage &gt;= fileSize);</span><br><span class="line">            // if we can&apos;t extend size, rollback to old state</span><br><span class="line">            if (!m_file-&gt;truncate(fileSize)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return doFullWriteBack(move(preparedData), nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool MemoryFile::truncate(size_t size) &#123;</span><br><span class="line">    。。。。。。。。</span><br><span class="line">    // 重新通过 mmap 映射 </span><br><span class="line">    auto ret = mmap();</span><br><span class="line">    if (!ret) &#123;</span><br><span class="line">        doCleanMemoryCache(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MMKV::doFullWriteBack(pair&lt;MMBuffer, size_t&gt; preparedData, AESCrypt *newCrypter) &#123;</span><br><span class="line">    auto ptr = (uint8_t *) m_file-&gt;getMemory();</span><br><span class="line">    auto totalSize = preparedData.second;</span><br><span class="line">#ifdef MMKV_IOS</span><br><span class="line">    auto ret = guardForBackgroundWriting(ptr + Fixed32Size, totalSize);</span><br><span class="line">    if (!ret.first) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">    uint8_t newIV[AES_KEY_LEN];</span><br><span class="line">    auto decrypter = m_crypter;</span><br><span class="line">    auto encrypter = (newCrypter == InvalidCryptPtr) ? nullptr : (newCrypter ? newCrypter : m_crypter);</span><br><span class="line">    if (encrypter) &#123;</span><br><span class="line">        AESCrypt::fillRandomIV(newIV);</span><br><span class="line">        encrypter-&gt;resetIV(newIV, sizeof(newIV));</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    delete m_output;</span><br><span class="line">    m_output = new CodedOutputData(ptr + Fixed32Size, m_file-&gt;getFileSize() - Fixed32Size);</span><br><span class="line">#ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        memmoveDictionary(*m_dicCrypt, m_output, ptr, decrypter, encrypter, preparedData);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">#else</span><br><span class="line">    &#123;</span><br><span class="line">        auto encrypter = m_crypter;</span><br><span class="line">#endif</span><br><span class="line">        memmoveDictionary(*m_dic, m_output, ptr, encrypter, totalSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_actualSize = totalSize;</span><br><span class="line">#ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">    if (encrypter) &#123;</span><br><span class="line">        recaculateCRCDigestWithIV(newIV);</span><br><span class="line">    &#125; else</span><br><span class="line">#endif</span><br><span class="line">    &#123;</span><br><span class="line">        recaculateCRCDigestWithIV(nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    m_hasFullWriteback = true;</span><br><span class="line">    // make sure lastConfirmedMetaInfo is saved</span><br><span class="line">    sync(MMKV_SYNC);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存重整步骤如下：</p>
<ul>
<li>当剩余映射空间不足以写入需要写入的内容，尝试进行内存重整;</li>
<li>内存重整会将文件清空，将 map 中的数据重新写入文件，从而去除冗余数据;</li>
<li>若内存重整后剩余映射空间仍然不足，不断将映射空间 double 直到足够，并用 mmap 重新映射;<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int32_t MMKV::getInt32(MMKVKey_t key, int32_t defaultValue, bool *hasValue) &#123;</span><br><span class="line">    if (isKeyEmpty(key)) &#123;</span><br><span class="line">        if (hasValue != nullptr) &#123;</span><br><span class="line">            *hasValue = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPED_LOCK(m_lock);</span><br><span class="line">    auto data = getDataForKey(key);</span><br><span class="line">    if (data.length() &gt; 0) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            CodedInputData input(data.getPtr(), data.length());</span><br><span class="line">            if (hasValue != nullptr) &#123;</span><br><span class="line">                *hasValue = true;</span><br><span class="line">            &#125;</span><br><span class="line">            return input.readInt32();</span><br><span class="line">        &#125; catch (std::exception &amp;exception) &#123;</span><br><span class="line">            MMKVError(&quot;%s&quot;, exception.what());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasValue != nullptr) &#123;</span><br><span class="line">        *hasValue = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return defaultValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MMBuffer MMKV::getDataForKey(MMKVKey_t key) &#123;</span><br><span class="line">    checkLoadData();</span><br><span class="line">#ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        auto itr = m_dicCrypt-&gt;find(key);</span><br><span class="line">        if (itr != m_dicCrypt-&gt;end()) &#123;</span><br><span class="line">            auto basePtr = (uint8_t *) (m_file-&gt;getMemory()) + Fixed32Size;</span><br><span class="line">            return itr-&gt;second.toMMBuffer(basePtr, m_crypter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else</span><br><span class="line">#endif</span><br><span class="line">    &#123;</span><br><span class="line">        auto itr = m_dic-&gt;find(key);</span><br><span class="line">        if (itr != m_dic-&gt;end()) &#123;</span><br><span class="line">            auto basePtr = (uint8_t *) (m_file-&gt;getMemory()) + Fixed32Size;</span><br><span class="line">            return itr-&gt;second.toMMBuffer(basePtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MMBuffer nan;</span><br><span class="line">    return nan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>调用了 getDataForKey 方法获取到了 key 对应的 MMBuffer，之后通过 CodedInputData 将数据读出并返回;没有时，返回默认值MMBuffer nan;</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void MMKV::removeValueForKey(MMKVKey_t key) &#123;</span><br><span class="line">    if (isKeyEmpty(key)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPED_LOCK(m_lock);</span><br><span class="line">    SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line">    checkLoadData();</span><br><span class="line"></span><br><span class="line">    removeDataForKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它在数据读入内存的前提下，调用了 removeDataForKey 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool MMKV::removeDataForKey(MMKVKey_t key) &#123;</span><br><span class="line">    if (isKeyEmpty(key)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">#ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">    if (m_crypter) &#123;</span><br><span class="line">        auto itr = m_dicCrypt-&gt;find(key);</span><br><span class="line">        if (itr != m_dicCrypt-&gt;end()) &#123;</span><br><span class="line">            m_hasFullWriteback = false;</span><br><span class="line">            构造了一条 size 为 null的 MMBuffer </span><br><span class="line">            static MMBuffer nan;</span><br><span class="line">#    ifdef MMKV_APPLE</span><br><span class="line">            auto ret = appendDataWithKey(nan, key, itr-&gt;second);</span><br><span class="line">            if (ret.first) &#123;</span><br><span class="line">                auto oldKey = itr-&gt;first;</span><br><span class="line">                m_dicCrypt-&gt;erase(itr);</span><br><span class="line">                [oldKey release];</span><br><span class="line">            &#125;</span><br><span class="line">#    else</span><br><span class="line">            auto ret = appendDataWithKey(nan, key);</span><br><span class="line">            if (ret.first) &#123;</span><br><span class="line">                m_dicCrypt-&gt;erase(itr);</span><br><span class="line">            &#125;</span><br><span class="line">#    endif</span><br><span class="line">            return ret.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实际上是构造了一条 size 为null 的 MMBuffer 并调用 appendDataWithKey 将其 append 到 protobuf 文件中，并将 key 对应的内容从 map 中删除;读取时发现它的 size 为 null，则会认为这条数据已经删除;</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><strong>MMKV</strong></p>
<ul>
<li>1.protobuf文件存储，文件更小;</li>
<li>2.采用mmap，文件拷贝速度更快; </li>
<li>3.不阻塞主线程，采用缺页方式，避免数据丢失。</li>
<li>4.支持增量更新，不管key是否重复，直接将数据加载前数据后。</li>
<li>5.文件大小不够，就需要全量写入：但是需要首先去重，去重后，如果空间够，就把数据编码成mmkv文件格式，全量的覆盖写入文件，如果不够，就需要先扩容（*2）；</li>
<li>6.扩容，设置文件大小*2，通过unmap，解除映射；重新映射mmap(size * 2),这里是个do while循环判断；</li>
<li>7.如果文件损坏：回调给开发者或者默认直接丢失数据，重新保存数据。</li>
<li>8.支持多进程：文件锁flock。多进程数据同步：crc32校验</li>
<li><em>数据对比*</em><br><img src="http://nunu03.github.io/2022/06/03/SharedPreferences-MMAP-MMKV%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/sp-data.png" alt><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><a href="https://juejin.cn/post/6926825172066369544" target="_blank" rel="noopener">关于SharePreference使用以及内部原理简单解析</a><br><a href="https://www.jianshu.com/p/40e42da910e2?utm_campaign=maleskine" target="_blank" rel="noopener">庖丁解牛之SharedPreferences超级大卡顿</a><br><a href="https://github.com/Tencent/MMKV/blob/master/README_CN.md" target="_blank" rel="noopener">MMKV</a><br><a href="https://www.51cto.com/article/686452.html" target="_blank" rel="noopener">https://www.51cto.com/article/686452.html</a></li>
</ul>

        
            <div id="toc-article">
                
  <div class="widget-wrap" id="toc-wrap">
    <h3 class="widget-title"><i class="fa fa-toc"></i> Contents</h3>
    <div class="widget">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SharedPreferences"><span class="toc-text">SharedPreferences</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用"><span class="toc-text">如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获取"><span class="toc-text">获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commit"><span class="toc-text">commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#writeToFile"><span class="toc-text">writeToFile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apply"><span class="toc-text">apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读数据"><span class="toc-text">读数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源码总结"><span class="toc-text">源码总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MMAP"><span class="toc-text">MMAP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#传统I-O"><span class="toc-text">传统I/O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MMMAP"><span class="toc-text">MMMAP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#案例"><span class="toc-text">案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binder通信"><span class="toc-text">Binder通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MMKV"><span class="toc-text">MMKV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码"><span class="toc-text">源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化-1"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取MMKV对象"><span class="toc-text">获取MMKV对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载数据loadFromFile"><span class="toc-text">加载数据loadFromFile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写入"><span class="toc-text">写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存重整ensureMemorySize"><span class="toc-text">内存重整ensureMemorySize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取"><span class="toc-text">读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove"><span class="toc-text">remove</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
    </div>
  </div>


            </div>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://nunu03.github.io/2022/06/03/SharedPreferences-MMAP-MMKV数据持久化原理解析/">http://nunu03.github.io/2022/06/03/SharedPreferences-MMAP-MMKV数据持久化原理解析/</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mmap/">mmap</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
        
<nav id="article-nav">
  
    <a href="/2022/06/02/ViewModel源码解析/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">older</strong>
      <div class="article-nav-title">
        
          ViewModel源码解析
        
      </div>
    </a>
  
  
</nav>

      
      
        








      
    </footer>
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> Recent</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/03/SharedPreferences-MMAP-MMKV数据持久化原理解析/">SharedPreferences+MMAP+MMKV数据持久化原理解析</a>
          </li>
        
          <li>
            <a href="/2022/06/02/ViewModel源码解析/">ViewModel源码解析</a>
          </li>
        
          <li>
            <a href="/2022/06/02/LiveData-LifeCycle原理/">LiveData&amp;LifeCycle原理</a>
          </li>
        
          <li>
            <a href="/2022/06/01/Android-WMS原理/">Android WMS原理</a>
          </li>
        
          <li>
            <a href="/2022/05/31/OkHttp总结/">OkHttp总结</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/Charles/" style="font-size: 13.33px;">Charles</a> <a href="/tags/Color/" style="font-size: 10px;">Color</a> <a href="/tags/FaceUnity/" style="font-size: 16.67px;">FaceUnity</a> <a href="/tags/Fix/" style="font-size: 10px;">Fix</a> <a href="/tags/Flutter/" style="font-size: 10px;">Flutter</a> <a href="/tags/GitLab/" style="font-size: 10px;">GitLab</a> <a href="/tags/Gradle/" style="font-size: 20px;">Gradle</a> <a href="/tags/Haar/" style="font-size: 10px;">Haar</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Hook/" style="font-size: 10px;">Hook</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/LiveData/" style="font-size: 10px;">LiveData</a> <a href="/tags/Log/" style="font-size: 10px;">Log</a> <a href="/tags/OkHttp/" style="font-size: 10px;">OkHttp</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Retrofit/" style="font-size: 10px;">Retrofit</a> <a href="/tags/Title/" style="font-size: 10px;">Title</a> <a href="/tags/Toast/" style="font-size: 10px;">Toast</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/ViewModel/" style="font-size: 10px;">ViewModel</a> <a href="/tags/WMS/" style="font-size: 10px;">WMS</a> <a href="/tags/WebHook/" style="font-size: 10px;">WebHook</a> <a href="/tags/Wireshark/" style="font-size: 10px;">Wireshark</a> <a href="/tags/Xposed/" style="font-size: 13.33px;">Xposed</a> <a href="/tags/aar/" style="font-size: 10px;">aar</a> <a href="/tags/cmd/" style="font-size: 10px;">cmd</a> <a href="/tags/mmap/" style="font-size: 10px;">mmap</a> <a href="/tags/ngrok/" style="font-size: 13.33px;">ngrok</a> <a href="/tags/nps/" style="font-size: 10px;">nps</a> <a href="/tags/人脸检测/" style="font-size: 10px;">人脸检测</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Charles/">Charles</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GitLab/">GitLab</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gradle/">Gradle</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Log/">Log</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Log/Fix/">Fix</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/NDK/">NDK</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenCV/">OpenCV</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Video/">Video</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebHook/">WebHook</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/WebHook/ngrok/">ngrok</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/cmd/">cmd</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ngrok/">ngrok</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ngrok/nps/">nps</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/人脸检测/">人脸检测</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/人脸检测/Haar/">Haar</a><span class="category-list-count">1</span></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> Archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022年</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021年</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020年</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019年</a><span class="archive-list-count">16</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/">CMake</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Charles/">Charles</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Color/">Color</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FaceUnity/">FaceUnity</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fix/">Fix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/">Flutter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitLab/">GitLab</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Haar/">Haar</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hook/">Hook</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LiveData/">LiveData</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Log/">Log</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OkHttp/">OkHttp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenCV/">OpenCV</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/">Retrofit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Title/">Title</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Toast/">Toast</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ViewModel/">ViewModel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WMS/">WMS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebHook/">WebHook</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wireshark/">Wireshark</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xposed/">Xposed</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aar/">aar</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cmd/">cmd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mmap/">mmap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ngrok/">ngrok</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nps/">nps</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/人脸检测/">人脸检测</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> Blogroll</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a href="https://handsomeliuyang.github.io/">liuyang</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">Site Map</a>
        <span> | </span><a href="/atom.xml">Subscribe to this site</a>
        <span> | </span><a href="/about/">Contact the blogger</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2022 Nunu Long.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
  </div>
  <script src="/js/jquery-3.4.1.min.js"></script>
<script src="/js/search.json.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/script.js"></script>





  <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



  
    <script src="/localshare/js/social-share.js"></script>
    <script src="/localshare/js/qrcode.js"></script>
  
  



  

  

  

  

  

  

  

  
  





</body>
</html>